apiVersion: gateway.envoyproxy.io/v1alpha1
kind: EnvoyProxy
metadata:
  name: external-proxy-config
  namespace: platform
spec:
  provider:
    type: Kubernetes
    kubernetes:
      envoyDeployment:
        pod:
          volumes:
            - name: postgres-gateway-tls
              secret:
                secretName: postgres-gateway-tls
          volumeMounts:
            - name: postgres-gateway-tls
              mountPath: /etc/envoy-tls/postgres
              readOnly: true
  bootstrap:
    type: Merge
    value: |
      static_resources:
        listeners:
        # Postgres listener with SNI-based routing on port 5432
        - name: postgres_listener
          address:
            socket_address:
              address: 0.0.0.0
              port_value: 5432
          listener_filters:
          # Postgres inspector to detect PostgreSQL protocol
          - name: envoy.filters.listener.postgres_inspector
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.listener.postgres_inspector.v3alpha.PostgresInspector
          # TLS inspector to extract SNI from TLS handshake
          - name: envoy.filters.listener.tls_inspector
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.listener.tls_inspector.v3.TlsInspector
          filter_chains:
          # Filter chain for PostgreSQL connections
          - filter_chain_match:
              transport_protocol: "postgres"
            transport_socket:
              name: envoy.transport_sockets.tls
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext
                common_tls_context:
                  # Certificate for *.db.konnektr.io from cert-manager
                  tls_certificates:
                  - certificate_chain:
                      filename: /etc/envoy-tls/postgres/tls.crt
                    private_key:
                      filename: /etc/envoy-tls/postgres/tls.key
            filters:
            # Lua filter to transform external hostname to internal Kubernetes DNS
            - name: envoy.filters.network.lua
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.lua.v3.Lua
                inline_code: |
                  function envoy_on_connection(connection_handle)
                    -- Get the SNI hostname (e.g., postgres-abc123-myapp-def456.db.konnektr.io)
                    -- Pattern: {service}-{random}-{namespace}-{random}.db.konnektr.io
                    -- Both service and namespace IDs have exactly one hyphen (name + random suffix)
                    local sni = connection_handle:requestedServerName()
                    
                    if sni ~= nil then
                      -- Extract combined from SNI pattern: {service}-{random}-{namespace}-{random}.db.konnektr.io
                      local combined = sni:match("^([^.]+)%.db%.konnektr%.io$")
                      
                      if combined ~= nil then
                        -- Split on the SECOND hyphen from the end to separate service from namespace
                        -- This handles: postgres-abc123-myapp-def456
                        --   -> service: postgres-abc123
                        --   -> namespace: myapp-def456
                        local parts = {}
                        for part in combined:gmatch("[^-]+") do
                          table.insert(parts, part)
                        end
                        
                        if #parts >= 4 then
                          -- Reconstruct: first n-2 parts are service, last 2 are namespace
                          local service_parts = {}
                          local namespace_parts = {}
                          
                          for i = 1, #parts - 2 do
                            table.insert(service_parts, parts[i])
                          end
                          
                          for i = #parts - 1, #parts do
                            table.insert(namespace_parts, parts[i])
                          end
                          
                          local service = table.concat(service_parts, "-")
                          local namespace = table.concat(namespace_parts, "-")
                          
                          -- Append -rw for CNPG read-write service
                          -- Transform to internal Kubernetes DNS: {service}-rw.{namespace}.svc.cluster.local
                          local internal_host = service .. "-rw." .. namespace .. ".svc.cluster.local"
                          
                          -- Set the upstream host for tcp_proxy to use
                          connection_handle:streamInfo():dynamicMetadata():set("envoy.lb", "host", internal_host)
                        end
                      end
                    end
                  end
            # Postgres proxy filter to handle PostgreSQL protocol and terminate SSL
            - name: envoy.filters.network.postgres_proxy
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.postgres_proxy.v3alpha.PostgresProxy
                stat_prefix: postgres
                terminate_ssl: true
            # TCP proxy with dynamic forward proxy for SNI-based routing
            - name: envoy.filters.network.tcp_proxy
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy
                stat_prefix: postgres_tcp
                cluster: postgres_dynamic_forward_proxy_cluster
                tunneling_config:
                  # Use the hostname set by Lua filter, or fall back to SNI
                  hostname: "%DYNAMIC_METADATA([\"envoy.lb\"][\"host\"])%:%REQUESTED_SERVER_NAME%"
                  # The %DYNAMIC_METADATA% will be populated by the Lua filter
                  # If it's empty, it falls back to %REQUESTED_SERVER_NAME%
        clusters:
        # Dynamic forward proxy cluster for SNI-based routing
        - name: postgres_dynamic_forward_proxy_cluster
          lb_policy: CLUSTER_PROVIDED
          cluster_type:
            name: envoy.clusters.dynamic_forward_proxy
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.clusters.dynamic_forward_proxy.v3.ClusterConfig
              dns_cache_config:
                name: postgres_dynamic_forward_proxy_cache
                dns_lookup_family: V4_ONLY
